// ASCII 32..127+åäöÅÄÖ, 5 bytes each
const uint8_t diodascii[5*(96+6)] = {
0b0000000,
0b0000000,
0b0000000,
0b0000000,
0b0000000,

0b0000000,
0b0000000,
0b1111001,
0b0000000,
0b0000000,

0b0000000,
0b1110000,
0b0000000,
0b1110000,
0b0000000,

0b0010100,
0b1111111,
0b0010100,
0b1111111,
0b0010100,

0b0010010,
0b0101010,
0b1111111,
0b0101010,
0b0100100,

0b1100010,
0b1100100,
0b0001000,
0b0010011,
0b0100011,

0b0110110,
0b1001001,
0b1010101,
0b0100010,
0b0000101,

0b0000000,
0b1010000,
0b1100000,
0b0000000,
0b0000000,

0b0000000,
0b0011100,
0b0100010,
0b1000001,
0b0000000,

0b0000000,
0b1000001,
0b0100010,
0b0011100,
0b0000000,

0b0010100,
0b0001000,
0b0111110,
0b0001000,
0b0010100,

0b0001000,
0b0001000,
0b0111110,
0b0001000,
0b0001000,

0b0000000,
0b0000001,
0b0000110,
0b0000000,
0b0000000,

0b0001000,
0b0001000,
0b0001000,
0b0001000,
0b0001000,

0b0000000,
0b0000011,
0b0000000,
0b0000000,
0b0000000,

0b0000010,
0b0000100,
0b0001000,
0b0010000,
0b0100000,

0b0111110,
0b1000101,
0b1001001,
0b1010001,
0b0111110,

0b0000000,
0b0100001,
0b1111111,
0b0000001,
0b0000000,

0b0100001,
0b1000011,
0b1000101,
0b1001001,
0b0110001,

0b1000010,
0b1000001,
0b1010001,
0b1101001,
0b1000110,

0b0001100,
0b0010100,
0b0100100,
0b1111111,
0b0000100,

0b1110010,
0b1010001,
0b1010001,
0b1010001,
0b1001110,

0b0011110,
0b0101001,
0b1001001,
0b1001001,
0b0000110,

0b1000000,
0b1000111,
0b1001000,
0b1010000,
0b1100000,

0b0110110,
0b1001001,
0b1001001,
0b1001001,
0b0110110,

0b0110000,
0b1001001,
0b1001001,
0b1001010,
0b0111100,

0b0000000,
0b0110110,
0b0110110,
0b0000000,
0b0000000,

0b0000000,
0b0110101,
0b0110110,
0b0000000,
0b0000000,

0b0001000,
0b0010100,
0b0100010,
0b1000001,
0b0000000,

0b0010100,
0b0010100,
0b0010100,
0b0010100,
0b0010100,

0b0000000,
0b1000001,
0b0100010,
0b0010100,
0b0001000,

0b0100000,
0b1000000,
0b1000101,
0b1001000,
0b0110000,

0b0100110,
0b1001001,
0b1001111,
0b1000001,
0b0111110,

0b0111111,
0b1000100,
0b1000100,
0b1000100,
0b0111111,

0b1111111,
0b1001001,
0b1001001,
0b1001001,
0b0110110,

0b0111110,
0b1000001,
0b1000001,
0b1000001,
0b0100010,

0b1111111,
0b1000001,
0b1000001,
0b0100010,
0b0011100,

0b1111111,
0b1001001,
0b1001001,
0b1001001,
0b1000001,

0b1111111,
0b1001000,
0b1001000,
0b1001000,
0b1000000,

0b0111110,
0b1000001,
0b1001001,
0b1001001,
0b0101111,

0b1111111,
0b0001000,
0b0001000,
0b0001000,
0b1111111,

0b0000000,
0b1000001,
0b1111111,
0b1000001,
0b0000000,

0b0000010,
0b0000001,
0b1000001,
0b1111110,
0b1000000,

0b1111111,
0b0001000,
0b0010100,
0b0100010,
0b1000001,

0b1111111,
0b0000001,
0b0000001,
0b0000001,
0b0000001,

0b1111111,
0b0100000,
0b0011000,
0b0100000,
0b1111111,

0b1111111,
0b0010000,
0b0001000,
0b0000100,
0b1111111,

0b0111110,
0b1000001,
0b1000001,
0b1000001,
0b0111110,

0b1111111,
0b1001000,
0b1001000,
0b1001000,
0b0110000,

0b0111110,
0b1000001,
0b1000101,
0b1000010,
0b0111101,

0b1111111,
0b1001000,
0b1001100,
0b1001010,
0b0110001,

0b0110001,
0b1001001,
0b1001001,
0b1001001,
0b1000110,

0b1000000,
0b1000000,
0b1111111,
0b1000000,
0b1000000,

0b1111110,
0b0000001,
0b0000001,
0b0000001,
0b1111110,

0b1111100,
0b0000010,
0b0000001,
0b0000010,
0b1111100,

0b1111110,
0b0000001,
0b0001110,
0b0000001,
0b1111110,

0b1100011,
0b0010100,
0b0001000,
0b0010100,
0b1100011,

0b1110000,
0b0001000,
0b0000111,
0b0001000,
0b1110000,

0b1000011,
0b1000101,
0b1001001,
0b1010001,
0b1100001,

0b0000000,
0b1111111,
0b1000001,
0b1000001,
0b0000000,

0b0000010,
0b0000100,
0b0001000,
0b0010000,
0b0100000,

0b0000000,
0b1000001,
0b1000001,
0b1111111,
0b0000000,

0b0010000,
0b0100000,
0b1000000,
0b0100000,
0b0010000,

0b0000001,
0b0000001,
0b0000001,
0b0000001,
0b0000001,

0b0000000,
0b1000000,
0b0100000,
0b0010000,
0b0000000,

0b0000010,
0b0010101,
0b0010101,
0b0010101,
0b0001111,

0b1111111,
0b0001001,
0b0010001,
0b0010001,
0b0001110,

0b0001110,
0b0010001,
0b0010001,
0b0010001,
0b0000010,

0b0001110,
0b0010001,
0b0010001,
0b0001001,
0b1111111,

0b0001110,
0b0010101,
0b0010101,
0b0010101,
0b0001100,
0b0001000,
0b0111111,
0b1001000,
0b1000000,
0b0100000,
0b0011000,
0b0100101,
0b0100101,
0b0100101,
0b0111110,
0b1111111,
0b0001000,
0b0010000,
0b0010000,
0b0001111,
0b0000000,
0b0010001,
0b1011111,
0b0000001,
0b0000000,
0b0000010,
0b0000001,
0b0010001,
0b1011110,
0b0000000,
0b1111111,
0b0000100,
0b0001010,
0b0010001,
0b0000000,
0b0000000,
0b1000001,
0b1111111,
0b0000001,
0b0000000,
0b0011111,
0b0010000,
0b0001100,
0b0010000,
0b0001111,
0b0011111,
0b0001000,
0b0010000,
0b0010000,
0b0001111,
0b0001110,
0b0010001,
0b0010001,
0b0010001,
0b0001110,
0b0011111,
0b0010100,
0b0010100,
0b0010100,
0b0001000,
0b0001000,
0b0010100,
0b0010100,
0b0001100,
0b0011111,
0b0011111,
0b0001000,
0b0010000,
0b0010000,
0b0001000,
0b0001001,
0b0010101,
0b0010101,
0b0010101,
0b0000010,
0b0010000,
0b1111110,
0b0010001,
0b0000001,
0b0000010,
0b0011110,
0b0000001,
0b0000001,
0b0000010,
0b0011111,
0b0011100,
0b0000010,
0b0000001,
0b0000010,
0b0011100,
0b0011110,
0b0000001,
0b0000110,
0b0000001,
0b0011110,
0b0010001,
0b0001010,
0b0000100,
0b0001010,
0b0010001,
0b0011000,
0b0000101,
0b0000101,
0b0000101,
0b0011110,
0b0010001,
0b0010011,
0b0010101,
0b0011001,
0b0010001,
0b0000000,
0b0001000,
0b0110110,
0b1000001,
0b0000000,
0b0000000,
0b0000000,
0b1111111,
0b0000000,
0b0000000,
0b0000000,
0b1000001,
0b0110110,
0b0001000,
0b0000000,
0b0001000,
0b0001000,
0b0101010,
0b0011100,
0b0001000,
0b0001000,
0b0011100,
0b0101010,
0b0001000,
0b0001000,
// å
0b0000010,
0b0010101,
0b1010101,
0b0010101,
0b0001111,
// ä
0b0000010,
0b1010101,
0b0010101,
0b1010101,
0b0001111,
// ö
0b0001110,
0b1010001,
0b0010001,
0b1010001,
0b0001110,
// Å
0b0000111,
0b0011100,
0b1010100,
0b0011100,
0b0000111,
// Ä
0b0000111,
0b1011100,
0b0010100,
0b1011100,
0b0000111,
// Ö
0b0011110,
0b1100001,
0b0100001,
0b1100001,
0b0011110,
};

uint8_t diodbits_from_ascii(int ascii, uint8_t idx)
{
	switch(ascii)
	{
	case 140: ascii = 128; break; //å
	case 138: ascii = 129; break; //ä
	case 154: ascii = 130; break; //ö
	case 129: ascii = 131; break; //Å
	case 128: ascii = 132; break; //Ä
     	case 133: ascii = 133; break; //Ö
	}
	return diodascii[((ascii)-32)*(uint16_t)5 + (uint16_t)(idx)];
}


//output pins
int led_pins[] = {4,5,6,7,8,9,10,11};
int clk_pin = 2;
int indicator = 13;

//constantsx
int delay_ticks = 25;
char l1 = 'A';
char l2 = 'B';
char l3 = 'C';

char ping[16];
char pong[16];

boolean value = HIGH;

char mask = 0x01;

void setup() {
  //clk pin
  pinMode(clk_pin,OUTPUT);
  pinMode(indicator,OUTPUT);
  
  //led matrix pins
  for(int i=0; i < 8; i++){
    pinMode(led_pins[i],OUTPUT);
  }
  Serial.begin(9600);
  
  diagnostic_pattern1();
  diagnostic_pattern2();
  
  while (!Serial) {
    ; // wait for serial port to connect. Needed for Leonardo only
  }  
}

void clock_once(){
  digitalWrite(clk_pin,LOW);
  delay(delay_ticks);
  digitalWrite(clk_pin,HIGH);
  delay(delay_ticks);
}

int skippedLines = 0;
void clock_letter(char letter){
  
  uint8_t row;
  
 for(int i=0; i < 5; i++){
   row = diodbits_from_ascii(letter,i);
   
   if((row == 0) && (letter > 35)){
     skippedLines = skippedLines + 1;
   }else{
     set_port(row);
     clock_once(); 
   }
 }
 set_port(0);
 clock_once();
 
}

//set 8 pins to byte pattern
void set_port(uint8_t p){
  
  for(int i=0; i < 8; i++){
    if(((p >> 6-i) & 0x01) == 0x01){
      //digitalWrite(led_pins[i],HIGH);
      digitalWrite(led_pins[i],HIGH);
    }else{
       //digitalWrite(led_pins[i],LOW); 
      digitalWrite(led_pins[i],LOW);
    }
  }
}

//Output whole string
void clock_string(String input){
   
     for(int i=0 ; i < 16; i++){
       if(i < input.length()){
        clock_letter(input[i]);
       }else{
         clock_letter(' ');
       }
      }
      
      while(skippedLines){
           set_port(0);
           clock_once();
           Serial.println(skippedLines);
           skippedLines = skippedLines - 1;
      }
}


//alternate high and low on al leds
void diagnostic_pattern1(){
    for(int i=0; i < 8; i++){
    digitalWrite(led_pins[i],HIGH); 
  }
  clock_once();
  for(int i=0; i < 8; i++){
    digitalWrite(led_pins[i],LOW);
  }  
  clock_once();
}

//chessboard pattern
void diagnostic_pattern2(){
    for(int i=0; i < 8; i++){
      if( i % 2 == 0){
           digitalWrite(led_pins[i],HIGH);
      }else{
         digitalWrite(led_pins[i],LOW);
      }
  }
  clock_once();
  for(int i=0; i < 8; i++){
    if( i % 2 == 1){
       digitalWrite(led_pins[i],HIGH);
    }else{
       digitalWrite(led_pins[i],LOW);
    }
  }  
  clock_once();
}



int last = 0;
int incoming[50];

char inData[50];
char inChar = -1;
byte index;

void loop() {

    while (Serial.available() > 0)
    {
        if(index < 49) // One less than the size of the array
        {
            inChar = Serial.read(); // Read a character
            inData[index] = inChar; // Store it
            index++; // Increment where to write next
            inData[index] = '\0'; // Null terminate the string
        }
    }
  
  if(index != 0){
    String inc = String(inData);
    inc.replace("kuken","foten");
    Serial.println(inc);
    clock_string(inc);
    index = 0;
  }
  
  //clock_string(inputstring);
}
